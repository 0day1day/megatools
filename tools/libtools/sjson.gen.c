/* Generated by re2c 0.13.5 on Mon Apr  8 18:08:37 2013 */
#line 1 "sjson.c"
/** 
 * sjson - fast string based JSON parser/generator
 *
 * Written by Ondrej Jirman <megous@megous.com>, 2013
 * WWW: https://github.com/megous/sjson
 */

#include <string.h>
#include <stdio.h>
#include "sjson.h"

enum
{
  TOK_NONE = 0, // no more tokens
  TOK_OBJ_START,
  TOK_OBJ_END,
  TOK_ARRAY_START,
  TOK_ARRAY_END,
  TOK_COLON,
  TOK_COMMA,
  TOK_STRING,
  TOK_NUMBER,
  TOK_FALSE,
  TOK_TRUE,
  TOK_NULL,
  TOK_INVALID
};

#line 49 "sjson.c"


static gint s_json_get_token(const gchar* json, const gchar** start, const gchar** end)
{
  g_return_val_if_fail(json != NULL, FALSE);

  const guchar* c = (const guchar*)json;
  const guchar* m = NULL;
  const guchar* s;
  gint token;

  while (TRUE)
  {
    s = c;


#line 49 "sjson.gen.c"
	{
		guchar yych;
		unsigned int yyaccept = 0;

		yych = (guchar)*c;
		if (yych <= '9') {
			if (yych <= ' ') {
				if (yych <= '\n') {
					if (yych <= 0x00) goto yy27;
					if (yych <= 0x08) goto yy29;
					if (yych >= '\n') goto yy4;
				} else {
					if (yych == '\r') goto yy2;
					if (yych <= 0x1F) goto yy29;
				}
			} else {
				if (yych <= ',') {
					if (yych == '"') goto yy14;
					if (yych <= '+') goto yy29;
					goto yy18;
				} else {
					if (yych <= '-') goto yy20;
					if (yych <= '/') goto yy29;
					if (yych <= '0') goto yy21;
					goto yy23;
				}
			}
		} else {
			if (yych <= 'm') {
				if (yych <= '\\') {
					if (yych <= ':') goto yy16;
					if (yych == '[') goto yy10;
					goto yy29;
				} else {
					if (yych <= ']') goto yy12;
					if (yych == 'f') goto yy25;
					goto yy29;
				}
			} else {
				if (yych <= 'z') {
					if (yych <= 'n') goto yy26;
					if (yych == 't') goto yy24;
					goto yy29;
				} else {
					if (yych <= '{') goto yy6;
					if (yych == '}') goto yy8;
					goto yy29;
				}
			}
		}
yy2:
		++c;
		yych = (guchar)*c;
		goto yy5;
yy3:
#line 65 "sjson.c"
		{ 
      continue; 
    }
#line 109 "sjson.gen.c"
yy4:
		++c;
		yych = (guchar)*c;
yy5:
		if (yych <= '\f') {
			if (yych <= 0x08) goto yy3;
			if (yych <= '\n') goto yy4;
			goto yy3;
		} else {
			if (yych <= '\r') goto yy4;
			if (yych == ' ') goto yy4;
			goto yy3;
		}
yy6:
		++c;
#line 69 "sjson.c"
		{
      token = TOK_OBJ_START;
      goto done;
    }
#line 130 "sjson.gen.c"
yy8:
		++c;
#line 74 "sjson.c"
		{
      token = TOK_OBJ_END;
      goto done;
    }
#line 138 "sjson.gen.c"
yy10:
		++c;
#line 79 "sjson.c"
		{
      token = TOK_ARRAY_START;
      goto done;
    }
#line 146 "sjson.gen.c"
yy12:
		++c;
#line 84 "sjson.c"
		{
      token = TOK_ARRAY_END;
      goto done;
    }
#line 154 "sjson.gen.c"
yy14:
		yyaccept = 0;
		yych = (guchar)*(m = ++c);
		goto yy55;
yy15:
#line 128 "sjson.c"
		{
      return TOK_INVALID;
    }
#line 164 "sjson.gen.c"
yy16:
		++c;
#line 94 "sjson.c"
		{
      token = TOK_COLON;
      goto done;
    }
#line 172 "sjson.gen.c"
yy18:
		++c;
#line 99 "sjson.c"
		{
      token = TOK_COMMA;
      goto done;
    }
#line 180 "sjson.gen.c"
yy20:
		yych = (guchar)*++c;
		if (yych <= '/') goto yy15;
		if (yych <= '0') goto yy53;
		if (yych <= '9') goto yy44;
		goto yy15;
yy21:
		yyaccept = 1;
		yych = (guchar)*(m = ++c);
		if (yych <= 'D') {
			if (yych == '.') goto yy46;
		} else {
			if (yych <= 'E') goto yy47;
			if (yych == 'e') goto yy47;
		}
yy22:
#line 104 "sjson.c"
		{
      token = TOK_NUMBER;
      goto done;
    }
#line 202 "sjson.gen.c"
yy23:
		yyaccept = 1;
		yych = (guchar)*(m = ++c);
		goto yy45;
yy24:
		yyaccept = 0;
		yych = (guchar)*(m = ++c);
		if (yych == 'r') goto yy40;
		goto yy15;
yy25:
		yyaccept = 0;
		yych = (guchar)*(m = ++c);
		if (yych == 'a') goto yy35;
		goto yy15;
yy26:
		yyaccept = 0;
		yych = (guchar)*(m = ++c);
		if (yych == 'u') goto yy30;
		goto yy15;
yy27:
		++c;
#line 124 "sjson.c"
		{ 
      return TOK_NONE;
    }
#line 228 "sjson.gen.c"
yy29:
		yych = (guchar)*++c;
		goto yy15;
yy30:
		yych = (guchar)*++c;
		if (yych == 'l') goto yy32;
yy31:
		c = m;
		if (yyaccept <= 0) {
			goto yy15;
		} else {
			goto yy22;
		}
yy32:
		yych = (guchar)*++c;
		if (yych != 'l') goto yy31;
		++c;
#line 119 "sjson.c"
		{
      token = TOK_NULL;
      goto done;
    }
#line 251 "sjson.gen.c"
yy35:
		yych = (guchar)*++c;
		if (yych != 'l') goto yy31;
		yych = (guchar)*++c;
		if (yych != 's') goto yy31;
		yych = (guchar)*++c;
		if (yych != 'e') goto yy31;
		++c;
#line 114 "sjson.c"
		{
      token = TOK_FALSE;
      goto done;
    }
#line 265 "sjson.gen.c"
yy40:
		yych = (guchar)*++c;
		if (yych != 'u') goto yy31;
		yych = (guchar)*++c;
		if (yych != 'e') goto yy31;
		++c;
#line 109 "sjson.c"
		{
      token = TOK_TRUE;
      goto done;
    }
#line 277 "sjson.gen.c"
yy44:
		yyaccept = 1;
		m = ++c;
		yych = (guchar)*c;
yy45:
		if (yych <= '9') {
			if (yych == '.') goto yy46;
			if (yych <= '/') goto yy22;
			goto yy44;
		} else {
			if (yych <= 'E') {
				if (yych <= 'D') goto yy22;
				goto yy47;
			} else {
				if (yych == 'e') goto yy47;
				goto yy22;
			}
		}
yy46:
		yych = (guchar)*++c;
		if (yych <= '/') goto yy31;
		if (yych <= '9') goto yy51;
		goto yy31;
yy47:
		yych = (guchar)*++c;
		if (yych <= ',') {
			if (yych != '+') goto yy31;
		} else {
			if (yych <= '-') goto yy48;
			if (yych <= '/') goto yy31;
			if (yych <= '9') goto yy49;
			goto yy31;
		}
yy48:
		yych = (guchar)*++c;
		if (yych <= '/') goto yy31;
		if (yych >= ':') goto yy31;
yy49:
		++c;
		yych = (guchar)*c;
		if (yych <= '/') goto yy22;
		if (yych <= '9') goto yy49;
		goto yy22;
yy51:
		yyaccept = 1;
		m = ++c;
		yych = (guchar)*c;
		if (yych <= 'D') {
			if (yych <= '/') goto yy22;
			if (yych <= '9') goto yy51;
			goto yy22;
		} else {
			if (yych <= 'E') goto yy47;
			if (yych == 'e') goto yy47;
			goto yy22;
		}
yy53:
		yyaccept = 1;
		yych = (guchar)*(m = ++c);
		if (yych <= 'D') {
			if (yych == '.') goto yy46;
			goto yy22;
		} else {
			if (yych <= 'E') goto yy47;
			if (yych == 'e') goto yy47;
			goto yy22;
		}
yy54:
		++c;
		yych = (guchar)*c;
yy55:
		if (yych == '"') goto yy57;
		if (yych != '\\') goto yy54;
		++c;
		yych = (guchar)*c;
		if (yych <= 'e') {
			if (yych <= '/') {
				if (yych == '"') goto yy54;
				if (yych <= '.') goto yy31;
				goto yy54;
			} else {
				if (yych <= '\\') {
					if (yych <= '[') goto yy31;
					goto yy54;
				} else {
					if (yych == 'b') goto yy54;
					goto yy31;
				}
			}
		} else {
			if (yych <= 'q') {
				if (yych <= 'f') goto yy54;
				if (yych == 'n') goto yy54;
				goto yy31;
			} else {
				if (yych <= 's') {
					if (yych <= 'r') goto yy54;
					goto yy31;
				} else {
					if (yych <= 't') goto yy54;
					if (yych <= 'u') goto yy59;
					goto yy31;
				}
			}
		}
yy57:
		++c;
#line 89 "sjson.c"
		{
      token = TOK_STRING;
      goto done;
    }
#line 390 "sjson.gen.c"
yy59:
		++c;
		yych = (guchar)*c;
		if (yych <= '@') {
			if (yych <= '/') goto yy31;
			if (yych >= ':') goto yy31;
		} else {
			if (yych <= 'F') goto yy60;
			if (yych <= '`') goto yy31;
			if (yych >= 'g') goto yy31;
		}
yy60:
		++c;
		yych = (guchar)*c;
		if (yych <= '@') {
			if (yych <= '/') goto yy31;
			if (yych >= ':') goto yy31;
		} else {
			if (yych <= 'F') goto yy61;
			if (yych <= '`') goto yy31;
			if (yych >= 'g') goto yy31;
		}
yy61:
		++c;
		yych = (guchar)*c;
		if (yych <= '@') {
			if (yych <= '/') goto yy31;
			if (yych >= ':') goto yy31;
		} else {
			if (yych <= 'F') goto yy62;
			if (yych <= '`') goto yy31;
			if (yych >= 'g') goto yy31;
		}
yy62:
		++c;
		yych = (guchar)*c;
		if (yych <= '@') {
			if (yych <= '/') goto yy31;
			if (yych <= '9') goto yy54;
			goto yy31;
		} else {
			if (yych <= 'F') goto yy54;
			if (yych <= '`') goto yy31;
			if (yych <= 'f') goto yy54;
			goto yy31;
		}
	}
#line 131 "sjson.c"

  }

done:
  if (start)
    *start = s;
  if (end)
    *end = c;
  return token;
}

SJsonType token_to_type(gint token)
{
  switch (token)
  {
    case TOK_NONE        : return S_JSON_TYPE_NONE;
    case TOK_OBJ_START   : return S_JSON_TYPE_OBJECT;
    case TOK_ARRAY_START : return S_JSON_TYPE_ARRAY;
    case TOK_STRING      : return S_JSON_TYPE_STRING;
    case TOK_NUMBER      : return S_JSON_TYPE_NUMBER;
    case TOK_FALSE       : return S_JSON_TYPE_BOOL;
    case TOK_TRUE        : return S_JSON_TYPE_BOOL;
    case TOK_NULL        : return S_JSON_TYPE_NULL;
    default              : return S_JSON_TYPE_INVALID;
  }
}

// public api

static gboolean s_json_is_valid_inner(const gchar* json, const gchar** end)
{
  const gchar* next;
  gint token;

  g_return_val_if_fail(json != NULL, FALSE);
  
  token = s_json_get_token(json, NULL, &next);
  if (token == TOK_ARRAY_START)
  {
    const gchar* array_elem = next;
    const gchar* array_next = NULL;
    gboolean expect_comma = FALSE;

    while (TRUE)
    {
      // check end of array
      token = s_json_get_token(array_elem, NULL, &array_next);
      if (token == TOK_ARRAY_END)
      {
        if (end)
          *end = array_next;
        return TRUE;
      }

      if (expect_comma)
      {
        if (token == TOK_COMMA)
          array_elem = array_next; // skip comma
        else
          return FALSE;
      }

      // check element
      if (!s_json_is_valid_inner(array_elem, &array_elem))
        return FALSE;

      expect_comma = TRUE;
    }
  }
  else if (token == TOK_OBJ_START)
  {
    const gchar* obj_next = next;
    gboolean expect_comma = FALSE;

    while (TRUE)
    {
      // check end of object
      token = s_json_get_token(obj_next, NULL, &obj_next);
      if (token == TOK_OBJ_END)
      {
        if (end)
          *end = obj_next;

        return TRUE;
      }

      // eat comma
      if (expect_comma)
      {
        if (token != TOK_COMMA)
          return FALSE;

        token = s_json_get_token(obj_next, NULL, &obj_next);
      }

      // check member name and colon
      if (token != TOK_STRING)
        return FALSE;

      token = s_json_get_token(obj_next, NULL, &obj_next);
      if (token != TOK_COLON)
        return FALSE;

      // check member value
      if (!s_json_is_valid_inner(obj_next, &obj_next))
        return FALSE;

      expect_comma = TRUE;
    }
  }
  else if (token == TOK_STRING || token == TOK_NUMBER || token == TOK_FALSE || token == TOK_TRUE || token == TOK_NULL)
  {
    if (end)
      *end = next;
    return TRUE;
  }

  return FALSE;
}

gboolean s_json_is_valid(const gchar* json)
{
  const gchar* next;

  g_return_val_if_fail(json != NULL, FALSE);
  
  return s_json_is_valid_inner(json, &next) && s_json_get_token(next, NULL, NULL) == TOK_NONE;
}

gchar* s_json_get(const gchar* json)
{
  const gchar* next;
  const gchar* start = NULL;

  g_return_val_if_fail(json != NULL, NULL);
  
  if (s_json_is_valid_inner(json, &next))
  {
    s_json_get_token(json, &start, NULL);
    if (!start)
      return NULL;

    return g_strndup(start, next - start);
  }

  return NULL;
}

SJsonType s_json_get_type(const gchar* json)
{
  g_return_val_if_fail(json != NULL, S_JSON_TYPE_INVALID);

  return token_to_type(s_json_get_token(json, NULL, NULL));
}

const gchar* s_json_get_element(const gchar* json, guint index)
{
  const gchar* elem;
  const gchar* next_elem;
  gint token;

  g_return_val_if_fail(json != NULL, NULL);

  token = s_json_get_token(json, NULL, &next_elem);
  if (token != TOK_ARRAY_START)
    return NULL;

  while (TRUE)
  {
    elem = next_elem;
    if (!s_json_is_valid_inner(elem, &next_elem))
      return NULL;

    if (index-- == 0)
      return elem;

    token = s_json_get_token(next_elem, NULL, &next_elem);
    if (token != TOK_COMMA)
      return NULL;
  }
}

gchar** s_json_get_elements(const gchar* json)
{
  const gchar* elem;
  const gchar* next_elem;
  gint token;
  GPtrArray* arr;

  g_return_val_if_fail(json != NULL, NULL);

  token = s_json_get_token(json, NULL, &next_elem);
  if (token != TOK_ARRAY_START)
    return NULL;

  arr = g_ptr_array_sized_new(64);

  if (s_json_get_token(next_elem, NULL, NULL) == TOK_ARRAY_END)
  {
    g_ptr_array_add(arr, NULL);
    return (gchar**)g_ptr_array_free(arr, FALSE);
  }

  while (TRUE)
  {
    elem = next_elem;
    if (!s_json_is_valid_inner(elem, &next_elem))
    {
      g_ptr_array_free(arr, TRUE);
      return NULL;
    }

    g_ptr_array_add(arr, (gchar*)elem);

    token = s_json_get_token(next_elem, NULL, &next_elem);
    if (token != TOK_COMMA)
    {
      if (token == TOK_ARRAY_END)
      {
        g_ptr_array_add(arr, NULL);
        return (gchar**)g_ptr_array_free(arr, FALSE);
      }
      
      g_ptr_array_free(arr, TRUE);
      return NULL;
    }
  }
}

const gchar* s_json_get_member(const gchar* json, const gchar* name)
{
  const gchar* member;
  const gchar* next_member;
  gint token;

  g_return_val_if_fail(json != NULL, NULL);
  g_return_val_if_fail(name != NULL, NULL);

  token = s_json_get_token(json, NULL, &next_member);
  if (token != TOK_OBJ_START)
    return NULL;

  while (TRUE)
  {
    member = next_member;

    token = s_json_get_token(member, NULL, &next_member);
    if (token != TOK_STRING)
      return NULL;

    token = s_json_get_token(next_member, NULL, &next_member);
    if (token != TOK_COLON)
      return NULL;

    gchar* member_name = s_json_get_string(member);
    if (!member_name)
      return NULL;

    // match member name
    if (!strcmp(member_name, name))
    {
      g_free(member_name);
      return next_member;
    }

    g_free(member_name);

    if (!s_json_is_valid_inner(next_member, &next_member))
      return NULL;

    token = s_json_get_token(next_member, NULL, &next_member);
    if (token != TOK_COMMA)
      return NULL;
  }

  return NULL;
}

gchar* s_json_get_string(const gchar* json)
{
  const gchar* start;
  const gchar* end;
  gint token;

  g_return_val_if_fail(json != NULL, NULL);

  token = s_json_get_token(json, &start, &end);
  if (token != TOK_STRING)
    return NULL;

  GString* str = g_string_sized_new(end - start);
  const guchar* c = (const guchar*)start + 1;
  const guchar* m = NULL;
  const guchar* s;

  while (TRUE)
  {
    s = c;


#line 739 "sjson.gen.c"
	{
		guchar yych;
		yych = (guchar)*c;
		if (yych <= '!') {
			if (yych <= 0x00) goto yy65;
			if (yych == '\n') goto yy68;
			goto yy67;
		} else {
			if (yych <= '"') goto yy72;
			if (yych == '\\') goto yy70;
			goto yy67;
		}
yy65:
		++c;
		yych = (guchar)*c;
		goto yy69;
yy66:
#line 431 "sjson.c"
		{
      g_string_append_len(str, s, c - s);
      continue;
    }
#line 762 "sjson.gen.c"
yy67:
		yych = (guchar)*++c;
		goto yy69;
yy68:
		++c;
		yych = (guchar)*c;
yy69:
		if (yych == '"') goto yy66;
		if (yych == '\\') goto yy66;
		goto yy68;
yy70:
		yych = (guchar)*(m = ++c);
		if (yych <= 'e') {
			if (yych <= '/') {
				if (yych == '"') goto yy76;
				if (yych >= '/') goto yy76;
			} else {
				if (yych <= '\\') {
					if (yych >= '\\') goto yy76;
				} else {
					if (yych == 'b') goto yy76;
				}
			}
		} else {
			if (yych <= 'q') {
				if (yych <= 'f') goto yy76;
				if (yych == 'n') goto yy76;
			} else {
				if (yych <= 's') {
					if (yych <= 'r') goto yy76;
				} else {
					if (yych <= 't') goto yy76;
					if (yych <= 'u') goto yy74;
				}
			}
		}
yy71:
#line 469 "sjson.c"
		{
      g_assert_not_reached();
    }
#line 804 "sjson.gen.c"
yy72:
		++c;
#line 460 "sjson.c"
		{
      return g_string_free(str, FALSE);
    }
#line 811 "sjson.gen.c"
yy74:
		yych = (guchar)*++c;
		if (yych <= '@') {
			if (yych <= '/') goto yy75;
			if (yych <= '9') goto yy78;
		} else {
			if (yych <= 'F') goto yy78;
			if (yych <= '`') goto yy75;
			if (yych <= 'f') goto yy78;
		}
yy75:
		c = m;
		goto yy71;
yy76:
		++c;
#line 436 "sjson.c"
		{
      gchar ch = (gchar)s[1];

      if (ch == 'b')
        g_string_append_c(str, '\b');
      else if (ch == 'n')
        g_string_append_c(str, '\n');
      else if (ch == 'r')
        g_string_append_c(str, '\r');
      else if (ch == 't')
        g_string_append_c(str, '\t');
      else
        g_string_append_c(str, ch);

      continue;
    }
#line 844 "sjson.gen.c"
yy78:
		yych = (guchar)*++c;
		if (yych <= '@') {
			if (yych <= '/') goto yy75;
			if (yych >= ':') goto yy75;
		} else {
			if (yych <= 'F') goto yy79;
			if (yych <= '`') goto yy75;
			if (yych >= 'g') goto yy75;
		}
yy79:
		yych = (guchar)*++c;
		if (yych <= '@') {
			if (yych <= '/') goto yy75;
			if (yych >= ':') goto yy75;
		} else {
			if (yych <= 'F') goto yy80;
			if (yych <= '`') goto yy75;
			if (yych >= 'g') goto yy75;
		}
yy80:
		yych = (guchar)*++c;
		if (yych <= '@') {
			if (yych <= '/') goto yy75;
			if (yych >= ':') goto yy75;
		} else {
			if (yych <= 'F') goto yy81;
			if (yych <= '`') goto yy75;
			if (yych >= 'g') goto yy75;
		}
yy81:
		++c;
#line 453 "sjson.c"
		{
      guint32 ch = 0;
      sscanf(s + 2, "%4x", &ch);
      g_string_append_unichar(str, ch);
      continue;
    }
#line 884 "sjson.gen.c"
	}
#line 472 "sjson.c"

  }

  return NULL;
}

gint64 s_json_get_int(const gchar* json, gint64 fallback)
{
  const gchar* start;
  const gchar* end;

  g_return_val_if_fail(json != NULL, fallback);

  if (s_json_get_token(json, &start, &end) != TOK_NUMBER)
    return fallback;

  gchar* str = g_alloca(end - start + 1);
  memcpy(str, start, end - start);
  str[end - start] = 0;

  gint64 v = fallback;
  sscanf(str, "%" G_GINT64_FORMAT, &v);
  return v;
}

gdouble s_json_get_double(const gchar* json, gdouble fallback)
{
  const gchar* start;
  const gchar* end;

  g_return_val_if_fail(json != NULL, fallback);

  if (s_json_get_token(json, &start, &end) != TOK_NUMBER)
    return fallback;

  gchar* str = g_alloca(end - start + 1);
  memcpy(str, start, end - start);
  str[end - start] = 0;

  gdouble v = fallback;
  sscanf(str, "%lf", &v);
  return v;
}

gboolean s_json_get_bool(const gchar* json)
{
  g_return_val_if_fail(json != NULL, FALSE);

  gint token = s_json_get_token(json, NULL, NULL);
  if (token == TOK_TRUE)
    return TRUE;

  return FALSE;
}

gboolean s_json_is_null(const gchar* json)
{
  g_return_val_if_fail(json != NULL, FALSE);

  gint token = s_json_get_token(json, NULL, NULL);
  if (token == TOK_NULL)
    return TRUE;

  return FALSE;
}

// helpers

gchar* s_json_get_member_string(const gchar* json, const gchar* name)
{
  g_return_val_if_fail(json != NULL, NULL);
  g_return_val_if_fail(name != NULL, NULL);

  const gchar* member = s_json_get_member(json, name);
  if (member)
    return s_json_get_string(member);

  return NULL;
}

gint64 s_json_get_member_int(const gchar* json, const gchar* name, gint64 fallback)
{
  g_return_val_if_fail(json != NULL, fallback);
  g_return_val_if_fail(name != NULL, fallback);

  const gchar* member = s_json_get_member(json, name);
  if (member)
    return s_json_get_int(member, fallback);

  return fallback;
}

gdouble s_json_get_member_double(const gchar* json, const gchar* name, gdouble fallback)
{
  g_return_val_if_fail(json != NULL, fallback);
  g_return_val_if_fail(name != NULL, fallback);

  const gchar* member = s_json_get_member(json, name);
  if (member)
    return s_json_get_double(member, fallback);

  return fallback;
}

gboolean s_json_get_member_bool(const gchar* json, const gchar* name)
{
  g_return_val_if_fail(json != NULL, FALSE);
  g_return_val_if_fail(name != NULL, FALSE);

  const gchar* member = s_json_get_member(json, name);
  if (member)
    return s_json_get_bool(member);

  return FALSE;
}

gboolean s_json_member_is_null(const gchar* json, const gchar* name)
{
  g_return_val_if_fail(json != NULL, FALSE);
  g_return_val_if_fail(name != NULL, FALSE);

  const gchar* member = s_json_get_member(json, name);
  if (member)
    return s_json_is_null(member);

  return TRUE;
}

// generator api

struct _SJsonGen
{
  GString* str;
};

SJsonGen* s_json_gen_new(void)
{
  SJsonGen* gen = g_slice_new(SJsonGen);
  gen->str = g_string_sized_new(512);
  return gen;
}

static void strip_comma(SJsonGen* json)
{
  if (json->str->len > 0)
  {
    if (json->str->str[json->str->len - 1] == ',')
      g_string_truncate(json->str, json->str->len - 1);
  }
}

void s_json_gen_start_object(SJsonGen* json)
{
  g_return_if_fail(json != NULL);

  g_string_append_c(json->str, '{');
}

void s_json_gen_end_object(SJsonGen* json)
{
  g_return_if_fail(json != NULL);

  strip_comma(json);
  g_string_append(json->str, "},");
}


void s_json_gen_start_array(SJsonGen* json)
{
  g_return_if_fail(json != NULL);

  g_string_append_c(json->str, '[');
}

void s_json_gen_end_array(SJsonGen* json)
{
  g_return_if_fail(json != NULL);

  strip_comma(json);
  g_string_append(json->str, "],");
}


void s_json_gen_string(SJsonGen* json, const gchar* v)
{
  g_return_if_fail(json != NULL);

  if (v)
  {
    const guchar* c = (const guchar*)v;
    const guchar* m = NULL;
    const guchar* s;

    g_string_append_c(json->str, '"');

    while (TRUE)
    {
      s = c;


#line 1087 "sjson.gen.c"
	{
		guchar yych;
		yych = (guchar)*c;
		if (yych <= '\f') {
			if (yych <= 0x08) {
				if (yych <= 0x00) goto yy97;
				if (yych <= 0x07) goto yy99;
				goto yy89;
			} else {
				if (yych <= '\t') goto yy91;
				if (yych >= '\v') goto yy99;
			}
		} else {
			if (yych <= '"') {
				if (yych <= '\r') goto yy87;
				if (yych <= '!') goto yy99;
				goto yy93;
			} else {
				if (yych == '\\') goto yy95;
				goto yy99;
			}
		}
		++c;
#line 672 "sjson.c"
		{ g_string_append(json->str, "\\n"); continue; }
#line 1113 "sjson.gen.c"
yy87:
		++c;
#line 673 "sjson.c"
		{ g_string_append(json->str, "\\r"); continue; }
#line 1118 "sjson.gen.c"
yy89:
		++c;
#line 674 "sjson.c"
		{ g_string_append(json->str, "\\b"); continue; }
#line 1123 "sjson.gen.c"
yy91:
		++c;
#line 675 "sjson.c"
		{ g_string_append(json->str, "\\t"); continue; }
#line 1128 "sjson.gen.c"
yy93:
		++c;
#line 676 "sjson.c"
		{ g_string_append(json->str, "\\\""); continue; }
#line 1133 "sjson.gen.c"
yy95:
		++c;
#line 677 "sjson.c"
		{ g_string_append(json->str, "\\\\"); continue; }
#line 1138 "sjson.gen.c"
yy97:
		++c;
#line 679 "sjson.c"
		{ 
      break;
    }
#line 1145 "sjson.gen.c"
yy99:
		++c;
		yych = (guchar)*c;
		if (yych <= '\r') {
			if (yych <= 0x07) {
				if (yych >= 0x01) goto yy99;
			} else {
				if (yych <= '\n') goto yy101;
				if (yych <= '\f') goto yy99;
			}
		} else {
			if (yych <= '"') {
				if (yych <= '!') goto yy99;
			} else {
				if (yych != '\\') goto yy99;
			}
		}
yy101:
#line 683 "sjson.c"
		{
      g_string_append_len(json->str, (gchar*)s, c - s);
      continue;
    }
#line 1169 "sjson.gen.c"
	}
#line 687 "sjson.c"

    }

    g_string_append(json->str, "\",");
  }
  else
    s_json_gen_null(json);
}

void s_json_gen_int(SJsonGen* json, gint64 v)
{
  g_return_if_fail(json != NULL);

  g_string_append_printf(json->str, "%" G_GINT64_FORMAT ",", v);
}

void s_json_gen_double(SJsonGen* json, gdouble v)
{
  g_return_if_fail(json != NULL);

  g_string_append_printf(json->str, "%lg,", v);
}

void s_json_gen_bool(SJsonGen* json, gboolean v)
{
  g_return_if_fail(json != NULL);

  g_string_append(json->str, v ? "true," : "false,");
}

void s_json_gen_null(SJsonGen* json)
{
  g_return_if_fail(json != NULL);

  g_string_append(json->str, "null,");
}


void s_json_gen_member_string(SJsonGen* json, const gchar* name, const gchar* v)
{
  g_return_if_fail(json != NULL);
  g_return_if_fail(name != NULL);

  s_json_gen_string(json, name);
  strip_comma(json);
  g_string_append_c(json->str, ':');
  s_json_gen_string(json, v);
}

void s_json_gen_member_int(SJsonGen* json, const gchar* name, gint64 v)
{
  g_return_if_fail(json != NULL);
  g_return_if_fail(name != NULL);

  s_json_gen_string(json, name);
  strip_comma(json);
  g_string_append_c(json->str, ':');
  s_json_gen_int(json, v);
}

void s_json_gen_member_double(SJsonGen* json, const gchar* name, gdouble v)
{
  g_return_if_fail(json != NULL);
  g_return_if_fail(name != NULL);

  s_json_gen_string(json, name);
  strip_comma(json);
  g_string_append_c(json->str, ':');
  s_json_gen_double(json, v);
}

void s_json_gen_member_bool(SJsonGen* json, const gchar* name, gboolean v)
{
  g_return_if_fail(json != NULL);
  g_return_if_fail(name != NULL);

  s_json_gen_string(json, name);
  strip_comma(json);
  g_string_append_c(json->str, ':');
  s_json_gen_bool(json, v);
}

void s_json_gen_member_null(SJsonGen* json, const gchar* name)
{
  g_return_if_fail(json != NULL);
  g_return_if_fail(name != NULL);

  s_json_gen_string(json, name);
  strip_comma(json);
  g_string_append_c(json->str, ':');
  s_json_gen_null(json);
}

void s_json_gen_member_array(SJsonGen* json, const gchar* name)
{
  g_return_if_fail(json != NULL);
  g_return_if_fail(name != NULL);

  s_json_gen_string(json, name);
  strip_comma(json);
  g_string_append_c(json->str, ':');
  s_json_gen_start_array(json);
}

void s_json_gen_member_object(SJsonGen* json, const gchar* name)
{
  g_return_if_fail(json != NULL);
  g_return_if_fail(name != NULL);

  s_json_gen_string(json, name);
  strip_comma(json);
  g_string_append_c(json->str, ':');
  s_json_gen_start_object(json);
}


gchar* s_json_gen_done(SJsonGen* json)
{
  g_return_val_if_fail(json != NULL, NULL);

  strip_comma(json);
  gchar* str = g_string_free(json->str, FALSE);
  g_slice_free(SJsonGen, json);
  return str;
}
